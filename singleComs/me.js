checkAdminLevel = require('../addons/checkAdminLevel.js');
module.exports = async ({message,replyWithSticker}) => {
	user = message.from, isReply = false;
	if (message.reply_to_message) user = message.reply_to_message.from, isReply = true;
	if (typeof nickNamesMemory[message.chat.id]==='undefined') getNick(message.chat.id,user.id);
	if (user.username) {
		d = await scrapeTelegram(user.username)
		var {
			username, name, pfp, bio } = d;
	} else {
		//name
		name = (user.last_name) ? user.first_name + ' ' + user.last_name : user.first_name;
		
		//username
		username = '@' + user.username;
		
		//no way to get bios via the telegram api, so it's blank.
		var bio;
		
		// pfp
		let imgs = await bot.telegram.getUserProfilePhotos(user.id),
			file = await bot.telegram.getFile(imgs.photos[0][1].file_id),
			url = 'https://api.telegram.org/file/bot' + token + '/' + file.file_path;
	}
	//rank
	rank = await checkAdminLevel(message, isReply);
	
	if (typeof name === 'undefined') name = ' ';
	if (typeof username === 'undefined') username = 'User ID #' + user.id;
	if (typeof bio === 'undefined') bio = 'Generated by Night Bot';
	if (typeof pfp === 'undefined') pfp = 'https://i.imgur.com/83svNGj.png';
	//console.log(name, username, bio, pfp);
	request({
		url: pfp,
		encoding: null
	}, async function(error, response, body) {
		var img = new Buffer(body.toString(), "binary").toString("base64");
		var Canvas = require('canvas-prebuilt'),
			Image = Canvas.Image,
			canvas = new Canvas(250, 250),
			context = canvas.getContext('2d'),
			centerX = canvas.width / 2,
			centerY = (canvas.height / 2) - 50,
			radius = 50;
		grd = context.createLinearGradient(canvas.height / 2, canvas.height, canvas.height / 2, 0);
		grd.addColorStop(0.000, '#1d1d1d');
		grd.addColorStop(1.000, '#434343');
		// Fill with gradient
		context.fillStyle = grd;
		context.fillRect(0, 0, canvas.width, canvas.height);
		
		
		// name
		context.font = fitTextOnCanvas(name, 'arial', context);
		context.textAlign = "center";
		context.fillStyle = "white";
		context.fillText(name, centerX, centerY + 80);
		
		
		// bio
		bio = bio.replace(/[^A-Za-z 0-9 \.,\?""!@#\$%\^&\*\(\)-_=\+;:<>\/\\\|\}\{\[\]`~]*/g, '');
		height = fitTextOnCanvas(bio, 'arial', context);
		wrapText(context, bio, centerX, centerY + 120, 230, height * 2);
		
		
		//username
		context.font = "italic bold 5px Arial";
		context.textAlign = "center";
		context.fillStyle = "lightgrey";
		context.fillText(username, centerX, centerY + 100);
		
		//pfp
		var thumbImg = new Image();
		thumbImg.onload = function() {
			var tmpCtx = canvas.getContext('2d');
			tmpCtx.save();
			tmpCtx.beginPath();
			tmpCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
			tmpCtx.closePath();
			tmpCtx.clip();
			tmpCtx.drawImage(thumbImg, centerX - 50, centerY - 50, 100, centerY + 25);
			tmpCtx.beginPath();
			//tmpCtx.arc(0, 0, 25, 0, Math.PI * 2, true);
			tmpCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
			tmpCtx.clip();
			tmpCtx.closePath();
			tmpCtx.restore();
			tmpCtx.beginPath();
		};
		thumbImg.src = body;
		try {
			let temp_msg = await replyWithSticker({
				source: canvas.toBuffer()
			});
			inline_keyboard = [];
			if (message.chat.type !== 'private') {
				inline_keyboard.push([{
					text: 'Currently Level ' + rank,
					callback_data: 'doNothing'
				}]);
			}if (nickNamesMemory[message.chat.id] && nickNamesMemory[message.chat.id][user.id]) {
				inline_keyboard.push([{
					text: '"'+nickNamesMemory[message.chat.id][user.id]+'"',
					callback_data: 'doNothing'
				}]);
			}
			if (username) {
				inline_keyboard.unshift([{
					text: 'Send Message',
					url: 'https://t.me/' + user.username
				}]);
			}
			inline_keyboard.push([{
				text: 'User ID: ' + user.id,
				callback_data: 'doNothing'
			}]);
			//console.log(inline_keyboard);
			bot.telegram.editMessageReplyMarkup(message.chat.id, temp_msg.message_id, '', {
				inline_keyboard: inline_keyboard
			})
		}catch(err){console.log(err);}
	});
}
//from https://stackoverflow.com/a/20552063
function fitTextOnCanvas(text, fontface, context, maxWidth, fontSize) {
	// start with a large font size
	var fontsize = fontSize || 25;
	var maxWidth = maxWidth || 250;
	// lower the font size until the text fits the canvas
	do {
		fontsize--;
		context.font = fontsize + "px " + fontface;
	} while (context.measureText(text).width > maxWidth)
	return fontsize;
}
async function scrapeTelegram(username) {
	console.log(username);
	let page = await scrapeIt("https://t.me/" + username, {
		bio: ".tgme_page_description",
		name: ".tgme_page_title",
		username: ".tgme_page_extra",
		pfp: {
			selector: ".tgme_page_photo_image",
			attr: "src"
		}
	});
	return page;
}

function wrapText(context, text, x, y, maxWidth, lineHeight) {
	l = text.length;
	switch (true) {
		case (l > 35 && l < 71): //36-70
			maxLine = 18;
			maxLines = 4;
			lines = ['', '', '', ''];
			break;
		case (l > 19 && l < 36): // 19-36
			maxLine = 35;
			maxLines = 3;
			lines = ['', '', ''];
			break;
		case (l > 0 && l < 18): // 0-18
			maxLine = 18;
			maxLines = 2;
			lines = ['', ''];
			break;
		
		default:
			maxLine = 18;
			maxLines = 1;
			lines = [''];
			break;
	}
	//words = text.match(/.{1,35}/g); 
	var words = text.split(' ');
	//words.push(' ',' ',' ',' ')
	var n = 0;
	for (var lineNum = 0; lineNum < lines.length; lineNum++) {
		for (var n = n; lines[lineNum].length < maxLine; n++) {
			if (typeof words[n] === 'undefined') break;
			lines[lineNum] += words[n] + ' ';
		}
	}
	context.font = fitTextOnCanvas(lines[i], 'arial', context, maxWidth, 18);
	for (var i = 0; i < lines.length; i++) {
		context.fillText(lines[i], x, y);
		y = y + lineHeight;
	}
}